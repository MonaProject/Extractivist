# -*- coding: utf-8 -*-import jsonimport sysimport hashlibfrom collections import Counterfrom pymongo import MongoClient  # ------------------------------------------------------------------------ ## Retrieves events from the 'occurrences' collection. Supports both search by# entity label and category (http://purl.org/dc/terms/subject)def retrieve_concurrences(type, entity):  client = MongoClient()  db = client.monastery2  dbs = {'actors': db.actors, 'events': db.events, 'places': db.places, 'times': db.times}    entities = []  if len(entity) > 5 and entity[:len('category:')] == 'category:':    cursor = dbs[type].find({'categories': entity[len('category:'):]}, {'label': 1, '_id': 0})        for x in cursor:      entities += [x['label']]  else:    entities = [entity]      events = db.concurrences.find({type: {'$in': entities}}, {'_id': 0})    return events# Retrieves data that we can later use to add data to entitiesdef retrieve_entity_data(data):  client = MongoClient()  db = client.monastery2  dbs = {'actors': db.actors, 'events': db.events, 'places': db.places, 'times': db.times}  for type in dbs:    cursor = dbs[type].find({'label': {'$in': data[type]['list']}}, {'_id': 0})        for x in cursor:      data[type]['raw'][x['label']] = x    return data# Pass a data to this functiondef get_entities_with_event_id(data, type, id):  found_entities = []  for entity in data[type]['raw']:    if id in data[type]['output'][entity]['events']:      found_entities += [data[type]['raw'][entity]]    return found_entities#def get_geo_hierarchy():  client = MongoClient()  db = client.monastery2  cursor = db.geo.find({}, {'_id': 0})  geo = {}    for x in cursor:    geo[x['label']] = x    return geo#def get_country_of_place(geo, label):  if label in geo:    hierarchy = geo[label]['hierarchy']    for place in hierarchy:      if 'PCL' in place['fcode']:        return place['name'] #def get_continent_of_place(geo, label):  if label in geo:    hierarchy = geo[label]['hierarchy']    for place in hierarchy:      if 'CONT' == place['fcode']:        return place['name']#def is_country(geo, label):  if label in geo:    hierarchy = geo[label]['hierarchy']    return 'PCL' in hierarchy[-1]['fcode']  return False# def add_places(data):  geo = get_geo_hierarchy()  for type in data:    for entity in data[type]['output']: # entity is a name      for event in data[type]['output'][entity]['events']:        places = get_entities_with_event_id(data, 'places', event)                if 'places' not in data[type]['output'][entity]:          data[type]['output'][entity]['places'] = []        for place in places:          data[type]['output'][entity]['places'] += [{'event_id': event,                                                      'label': place['label'],                                                      'coordinates': place['location'],                                                      'country': get_country_of_place(geo, place['label']),                                                      'continent': get_continent_of_place(geo, place['label']),                                                      'is_country': is_country(geo, place['label'])}]  return data# def add_continents(data):  for entity in data['places']['output']: # entity is a name    continent = data['places']['output'][entity]['places'][0]['continent']    data['places']['output'][entity]['continent'] = continent  return data  #def add_actor_types(data):  # Manually selected from initial list  dbpedia_person = ['Person', 'OfficeHolder', 'PersonFunction', 'EthnicGroup', 'Politician', 'Senator', 'Writer', 'Artist', 'President', 'Scientist', 'MilitaryPerson', 'MemberOfParliament']  dbpedia_organization = ['Place', 'PopulatedPlace', 'Country', 'Organisation', 'Organization', 'Company', 'Non-ProfitOrganisation', 'GovernmentAgency', 'GovernmentOrganization', 'EducationalOrganization', 'EducationInstitution', 'University', 'CollegeOrUniversity', 'MilitaryUnit']  freebase_person = ['/organization/organization_member', '/people/person', '/people/appointed_role', '/business/job_title']  freebase_organization = ['/organization/organization']    person_points = 0  organization_points = 0  for entity in data['actors']['output']:    data['actors']['output'][entity]['actor_type'] = ''    corenlp_type = data['actors']['raw'][entity]['corenlp_types']    if len(corenlp_type):      if corenlp_type[0] == 'PERSON':        data['actors']['output'][entity]['actor_type'] = 'Person'      elif corenlp_type[0] == 'ORGANIZATION':        data['actors']['output'][entity]['actor_type'] = 'Organization'      elif corenlp_type[0] == 'LOCATION':        data['actors']['output'][entity]['actor_type'] = 'Place'    else:      for attribute in data['actors']['output'][entity]:        if attribute == 'dbpedia_types':          for tag in dbpedia_person:            if tag in data['actors']['output'][entity][attribute]:              person_points += 1          for tag in dbpedia_organization:            if tag in data['actors']['output'][entity][attribute]:              organization_points += 1        if attribute == 'freebase_types':          for tag in freebase_person:            if tag in data['actors']['output'][entity][attribute]:              person_points += 2          for tag in freebase_organization:            if tag in data['actors']['output'][entity][attribute]:              organization_points += 2          if person_points > 0:        data['actors']['output'][entity]['actor_type'] = 'Person'      elif organization_points > person_points:        data['actors']['output'][entity]['actor_type'] = 'Organization'      else:        data['actors']['output'][entity]['actor_type'] = ''      # Override everything (when no corenlp type is present)      if entity in data['places']['output']:        data['actors']['output'][entity]['actor_type'] = 'Place'   return data# def add_times(data):  outlier_times = []  for type in data:    for entity in data[type]['output']: # entity is a name      for event in data[type]['output'][entity]['events']:        times = get_entities_with_event_id(data, 'times', event)        if 'timestamps' not in data[type]['output'][entity]:          data[type]['output'][entity]['timestamps'] = []        for time in times:          if int(time['start'][:4]) > 1980 and int(time['finish'][:4]) < 2020:            data[type]['output'][entity]['timestamps'] += [{'event_id': event,                                                            'timestamp_label': time['label'],                                                            'start': time['start'],                                                            'finish': time['finish']}]          elif type == 'times':            outlier_times += [entity]    for outlier in outlier_times:    if outlier in data['times']['output']:      del data['times']['output'][outlier]  return data#def get_sources():  client = MongoClient()  db = client.monastery2    cursor = db.articles.find({}, {'url': 1, 'date': 1, 'title': 1, 'id': 1, 'site': 1, '_id': 0})    sources = {}  for x in cursor:    sources[x['id']] = x    return sources#def add_sources(data):  # First run, add article IDs  for type in data:    for entity in data[type]['output']: # entity is still a name, it's not like it's suddenly going to be different you know      if not 'articles' in data[type]['output'][entity]:        data[type]['output'][entity]['articles'] = []        data[type]['output'][entity]['sources'] = []        data[type]['output'][entity]['mentions'] = []      for event in data[type]['output'][entity]['events']:        for mention in data[type]['raw'][entity]['mentions']:          if mention['id'] == event:            data[type]['output'][entity]['articles'] += [mention['article']]            data[type]['output'][entity]['mentions'] += [{'event_id': mention['id'], 'article_id': mention['article']}]  # Second run, add more information about the articles  sources = get_sources()    for type in data:    for entity in data[type]['output']:      article_ids = list(set(data[type]['output'][entity]['articles']))      data[type]['output'][entity]['sources'] = []            for id in article_ids:        data[type]['output'][entity]['sources'] += [sources[id]]    return data          # Retrieves all the names of entities which occur in events in which [entity]# also occurs, and puts it in a dict that we can use to add more data to  # data['events']['output']['have']  # {  #   "uid": "have (event)",  #   "type": "Event",  #   "events": [  #     1729,  #     2112  #   ],  #   "value": 2,  #   "label": "have"  # }def retrieve_events(type, entity):  events = retrieve_concurrences(type, entity)    data = {'actors': {'list': [], 'raw': {}, 'output': {} },          'events': {'list': [], 'raw': {}, 'output': {} },          'places': {'list': [], 'raw': {}, 'output': {} },          'times' : {'list': [], 'raw': {}, 'output': {} }}  # First, get the basic stuff so that we can create our output list  for event in events:    for type in data:      # event[type] is a list of entities for a specific type of entity in an event      for data_entity in event[type]:        if not data_entity is None and not '\\/' in data_entity: # and not (data_entity == entity and not entity[:len('category:')] == 'category:')       | This actually breaks things in some cases          # Add a new entry to the data dictionary          if len(data_entity) and data_entity not in data[type]['output']:            data[type]['output'][data_entity] = {'label': data_entity, 'events': []}            data[type]['output'][data_entity]['type'] = type[0].upper() + type[1:-1]            data[type]['output'][data_entity]['uid'] = data_entity + ' (' + type[:-1] + ')'            # This will save us some trouble later            data[type]['list'] += [data_entity]          # Update the entry now that we've found another mention          data[type]['output'][data_entity]['events'] += [event['id']]          data[type]['output'][data_entity]['value'] = len(list(set(data[type]['output'][data_entity]['events'])))  # Next, grab all necessary data (and some more) from the database so that we  # can enrich the data  data = retrieve_entity_data(data)    # Now add that data  data = add_places(data)  data = add_times(data)  data = add_sources(data) # Also responsible for the 'articles'  data = add_actor_types(data) # Only works on actors obviously  data = add_continents(data)    # Quickfix for duplicate events  for type in data:    for thing in data[type]['output']:      data[type]['output'][thing]['events'] = list(set(data[type]['output'][thing]['events']))      data[type]['output'][thing]['value'] = len(data[type]['output'][thing]['events'])    return data  # Main functiondef retrieve_data(type, entity):  data = retrieve_events(type, entity)    # Convert the dict to a format that the front-end understands  output = {}  for type in data:    output[type] = []    for entity in data[type]['output']:      output[type] += [data[type]['output'][entity]]    # Make sure that the most popular entities end up in the beginning        output[type] = sorted(output[type], key=lambda thing: thing['value'], reverse=True)    #f = open('debug.json', 'w')  #f.write(json.dumps(output, indent=2))  #f.close()    print json.dumps(output, indent=2)  # ------------------------------------------------------------------------ #type = sys.argv[1] # event, place, time or actorif type[-1] != 's':  type = type + 's'entity = sys.argv[2]retrieve_data(type, entity)